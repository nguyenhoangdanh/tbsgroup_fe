#!/usr/bin/env node
const { exec, execSync } = require('child_process');
const fs = require('fs');
const path = require('path');
const util = require('util');
const execPromise = util.promisify(exec);

/**
 * Script ƒë·ªÉ t·ª± ƒë·ªông review code b·∫±ng VSCode v√† GitHub Copilot
 * C√°ch s·ª≠ d·ª•ng: node vscode-copilot-review.js
 */

// C√°c c·∫•u h√¨nh
const CONFIG = {
    // C√°c extensions file c·∫ßn review
    extensions: ['.js', '.jsx', '.ts', '.tsx'],
    // C√°c th∆∞ m·ª•c/file c·∫ßn lo·∫°i tr·ª´
    excludePaths: ['node_modules', '.next', 'out', 'dist', 'build', '.git', 'code-reviews'],
    // Output directory ƒë·ªÉ l∆∞u k·∫øt qu·∫£ review
    outputDir: 'copilot-reviews',
    // S·ªë l∆∞·ª£ng file t·ªëi ƒëa ƒë·ªÉ review trong m·ªôt l·∫ßn ch·∫°y
    maxFiles: 10,
    // Th·ªùi gian ch·ªù t·ªëi ƒëa cho m·ªói file (ms)
    timeout: 30000
};

// T·∫°o th∆∞ m·ª•c output n·∫øu ch∆∞a t·ªìn t·∫°i
if (!fs.existsSync(CONFIG.outputDir)) {
    fs.mkdirSync(CONFIG.outputDir, { recursive: true });
}

/**
 * L·∫•y t·∫•t c·∫£ c√°c file trong project v·ªõi extension ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh
 */
function getAllFiles(dir, extensions, excludePaths) {
    let results = [];

    // Ki·ªÉm tra xem path c√≥ n·∫±m trong danh s√°ch lo·∫°i tr·ª´ kh√¥ng
    if (excludePaths.some(excludePath => dir.includes(excludePath))) {
        return results;
    }

    try {
        const list = fs.readdirSync(dir);

        list.forEach(file => {
            const fullPath = path.join(dir, file);

            try {
                const stat = fs.statSync(fullPath);

                if (stat && stat.isDirectory()) {
                    // ƒê·ªá quy v√†o th∆∞ m·ª•c con
                    results = results.concat(getAllFiles(fullPath, extensions, excludePaths));
                } else {
                    // Ki·ªÉm tra extension
                    const ext = path.extname(file);
                    if (extensions.includes(ext)) {
                        results.push(fullPath);
                    }
                }
            } catch (err) {
                // B·ªè qua c√°c l·ªói khi truy c·∫≠p file/th∆∞ m·ª•c
                console.log(`‚ö†Ô∏è Kh√¥ng th·ªÉ truy c·∫≠p: ${fullPath}`);
            }
        });
    } catch (err) {
        console.log(`‚ö†Ô∏è Kh√¥ng th·ªÉ ƒë·ªçc th∆∞ m·ª•c: ${dir}`);
    }

    return results;
}

/**
 * Ki·ªÉm tra VSCode ƒë∆∞·ª£c c√†i ƒë·∫∑t
 */
async function checkVSCode() {
    try {
        await execPromise('code --version');
        console.log('‚úÖ VSCode ƒë√£ ƒë∆∞·ª£c c√†i ƒë·∫∑t.');
        return true;
    } catch (error) {
        console.error('‚ùå VSCode CLI kh√¥ng kh·∫£ d·ª•ng. H√£y ƒë·∫£m b·∫£o VSCode ƒë√£ ƒë∆∞·ª£c c√†i ƒë·∫∑t v√† trong PATH.');
        return false;
    }
}

/**
 * Ki·ªÉm tra GitHub Copilot extension
 */
async function checkCopilotExtension() {
    try {
        const { stdout } = await execPromise('code --list-extensions | grep -i copilot');
        if (stdout.includes('github.copilot') || stdout.includes('GitHub.copilot') || stdout.includes('copilot')) {
            console.log('‚úÖ GitHub Copilot extension ƒë√£ ƒë∆∞·ª£c c√†i ƒë·∫∑t.');
            return true;
        } else {
            console.error('‚ùå Kh√¥ng t√¨m th·∫•y GitHub Copilot extension.');
            return false;
        }
    } catch (error) {
        console.error('‚ùå Kh√¥ng th·ªÉ ki·ªÉm tra GitHub Copilot extension.');
        return false;
    }
}

/**
 * T·∫°o t·ªáp VSCode task ƒë·ªÉ t·ª± ƒë·ªông review
 */
function createVSCodeTask(filePath) {
    const taskDir = path.join('.vscode', 'tasks');
    const taskFile = path.join(taskDir, 'copilot-review-task.json');

    if (!fs.existsSync(taskDir)) {
        fs.mkdirSync(taskDir, { recursive: true });
    }

    const taskConfig = {
        "version": "2.0.0",
        "tasks": [
            {
                "label": "Copilot Review",
                "type": "shell",
                "command": "echo 'Running Copilot Review for ${file}'",
                "problemMatcher": [],
                "group": {
                    "kind": "build",
                    "isDefault": true
                },
                "presentation": {
                    "reveal": "always",
                    "panel": "new"
                }
            }
        ]
    };

    fs.writeFileSync(taskFile, JSON.stringify(taskConfig, null, 2));
    console.log(`‚úÖ ƒê√£ t·∫°o t·ªáp task VSCode t·∫°i ${taskFile}`);
}

/**
 * T·∫°o t·ªáp VSCode keybinding ƒë·ªÉ t·ª± ƒë·ªông g·ªçi Copilot review
 */
function createVSCodeKeybinding() {
    // X√°c ƒë·ªãnh th∆∞ m·ª•c c·∫•u h√¨nh VSCode d·ª±a tr√™n h·ªá ƒëi·ªÅu h√†nh
    let configDir;
    if (process.platform === 'win32') {
        configDir = path.join(process.env.APPDATA, 'Code', 'User');
    } else if (process.platform === 'darwin') {
        configDir = path.join(process.env.HOME, 'Library', 'Application Support', 'Code', 'User');
    } else {
        configDir = path.join(process.env.HOME, '.config', 'Code', 'User');
    }

    const keybindingsFile = path.join(configDir, 'keybindings.json');

    // Ki·ªÉm tra n·∫øu file ƒë√£ t·ªìn t·∫°i
    let keybindings = [];
    if (fs.existsSync(keybindingsFile)) {
        try {
            keybindings = JSON.parse(fs.readFileSync(keybindingsFile, 'utf8'));
        } catch (error) {
            console.error(`‚ö†Ô∏è Kh√¥ng th·ªÉ ƒë·ªçc file keybindings hi·ªán t·∫°i: ${error.message}`);
            keybindings = [];
        }
    }

    // Ki·ªÉm tra xem keybinding ƒë√£ t·ªìn t·∫°i ch∆∞a
    const copilotReviewBinding = keybindings.find(kb =>
        kb.command === 'workbench.action.terminal.sendSequence' &&
        kb.args &&
        kb.args.text &&
        kb.args.text.includes('/review')
    );

    if (!copilotReviewBinding) {
        keybindings.push({
            "key": "ctrl+alt+r",
            "command": "workbench.action.terminal.sendSequence",
            "args": { "text": "/review\n" }
        });

        fs.writeFileSync(keybindingsFile, JSON.stringify(keybindings, null, 2));
        console.log(`‚úÖ ƒê√£ th√™m keybinding Ctrl+Alt+R cho Copilot review`);
    } else {
        console.log('‚úÖ Keybinding cho Copilot review ƒë√£ t·ªìn t·∫°i');
    }
}

/**
 * T·∫°o file JavaScript ƒë·ªÉ t·ª± ƒë·ªông th·ª±c hi·ªán review
 */
function createReviewerScript(filePath) {
    const reviewerPath = path.join(CONFIG.outputDir, 'reviewer.js');
    const fileContent = fs.readFileSync(filePath, 'utf8');

    const reviewerContent = `
// Reviewer script for ${filePath}

// Function that simulates the Copilot review process
function simulateCopilotReview() {
  // This is a placeholder for actual Copilot review
  // In a real implementation, this would interact with Copilot API
  
  const fileToReview = \`${filePath.replace(/\\/g, '\\\\')}\`;
  const fileContent = \`${fileContent.replace(/\\/g, '\\\\').replace(/`/g, '\\`')}\`;
  
  // Generate review based on file content
  const review = {
    filename: fileToReview,
    timestamp: new Date().toISOString(),
    suggestions: [
      {
        type: "performance",
        line: 1,
        description: "This is an automatically generated review suggestion. In a real implementation, GitHub Copilot would provide actual code review feedback here."
      }
    ]
  };
  
  return review;
}

// Run the review
const review = simulateCopilotReview();
console.log(JSON.stringify(review, null, 2));
`;

    fs.writeFileSync(reviewerPath, reviewerContent);
    console.log(`‚úÖ ƒê√£ t·∫°o script reviewer t·∫°i ${reviewerPath}`);

    return reviewerPath;
}

/**
 * Th·ª±c hi·ªán review m·ªôt file v·ªõi VSCode v√† Copilot
 */
async function reviewFile(filePath) {
    const outputFile = path.join(CONFIG.outputDir, `${path.basename(filePath)}.review.md`);
    console.log(`üîç ƒêang review file: ${filePath}`);

    try {
        // ƒê·ªçc n·ªôi dung file
        const fileContent = fs.readFileSync(filePath, 'utf8');

        // T·∫°o file markdown review m·∫∑c ƒë·ªãnh
        const reviewHeader = `# GitHub Copilot Review: ${filePath}\n\nReview ƒë∆∞·ª£c t·∫°o v√†o: ${new Date().toISOString()}\n\n`;
        fs.writeFileSync(outputFile, reviewHeader + "ƒêang th·ª±c hi·ªán review...\n", 'utf8');

        // Chu·∫©n b·ªã l·ªánh ƒë·ªÉ m·ªü VSCode v·ªõi file
        const vscodePath = 'code';
        const vscodeArgs = [
            '--wait',         // ƒê·ª£i cho ƒë·∫øn khi VSCode ƒë√≥ng
            '--new-window',   // M·ªü trong c·ª≠a s·ªï m·ªõi
            filePath,         // File c·∫ßn review
        ];

        // G·ª£i √Ω h∆∞·ªõng d·∫´n cho ng∆∞·ªùi d√πng
        console.log('\nüìù H∆∞·ªõng d·∫´n ƒë·ªÉ review file:');
        console.log('1. VSCode s·∫Ω m·ªü v·ªõi file c·∫ßn review');
        console.log('2. S·ª≠ d·ª•ng Copilot Chat (Ctrl+Shift+I) v√† nh·∫≠p l·ªánh "/review"');
        console.log('3. Sao ch√©p k·∫øt qu·∫£ review');
        console.log('4. L∆∞u v√†o file review ƒë∆∞·ª£c t·∫°o s·∫µn');
        console.log(`5. File review: ${outputFile}\n`);

        // T·∫°o script th·ª±c hi·ªán review t·ª± ƒë·ªông
        const reviewerScript = createReviewerScript(filePath);

        // Th·ª±c hi·ªán ph√¢n t√≠ch code t·ª± ƒë·ªông
        const analysisContent = `## Ph√¢n t√≠ch t·ª± ƒë·ªông

### Th√¥ng tin c∆° b·∫£n
- **File:** ${filePath}
- **K√≠ch th∆∞·ªõc:** ${fileContent.length} k√Ω t·ª±
- **S·ªë d√≤ng:** ${fileContent.split('\n').length} d√≤ng

### C√°c v·∫•n ƒë·ªÅ c√≥ th·ªÉ c√≥:
- Ki·ªÉm tra c·∫•u tr√∫c code
- Ki·ªÉm tra hi·ªáu su·∫•t
- Ki·ªÉm tra b·∫£o m·∫≠t
- Ki·ªÉm tra c√°c ph∆∞∆°ng ph√°p t·ªët nh·∫•t

### ƒê·ªÅ xu·∫•t review v·ªõi GitHub Copilot:
ƒê·ªÉ nh·∫≠n ƒë√°nh gi√° chi ti·∫øt, vui l√≤ng s·ª≠ d·ª•ng VSCode v·ªõi GitHub Copilot:
1. M·ªü file trong VSCode
2. M·ªü Copilot Chat (Ctrl+Shift+I)
3. Nh·∫≠p l·ªánh: /review
4. Sao ch√©p k·∫øt qu·∫£ review v√†o file n√†y

`;

        // C·∫≠p nh·∫≠t file review v·ªõi ph√¢n t√≠ch t·ª± ƒë·ªông
        fs.writeFileSync(outputFile, reviewHeader + analysisContent, 'utf8');

        // M·ªü VSCode v·ªõi file
        console.log(`üöÄ ƒêang m·ªü VSCode ƒë·ªÉ review file ${filePath}...`);
        try {
            execSync(`code "${filePath}"`, { stdio: 'inherit' });
            console.log(`‚úÖ VSCode ƒë√£ ƒë∆∞·ª£c m·ªü v·ªõi file ${filePath}`);
        } catch (error) {
            console.error(`‚ùå Kh√¥ng th·ªÉ m·ªü VSCode: ${error.message}`);
        }

        return true;
    } catch (error) {
        console.error(`‚ùå L·ªói khi review file ${filePath}:`, error.message);

        const errorContent = `# GitHub Copilot Review: ${filePath}\n\nReview ƒë∆∞·ª£c t·∫°o v√†o: ${new Date().toISOString()}\n\n‚ö†Ô∏è **L·ªñI KHI REVIEW FILE**\n\n\`\`\`\n${error.message}\n\`\`\`\n\nVui l√≤ng th·ª≠ l·∫°i sau ho·∫∑c review th·ªß c√¥ng.`;
        fs.writeFileSync(outputFile, errorContent, 'utf8');

        return false;
    }
}

/**
 * T·∫°o t·∫≠p l·ªánh PowerShell ƒë·ªÉ t·ª± ƒë·ªông h√≥a review trong VSCode
 */
function createPowerShellAutomation() {
    const scriptPath = path.join(CONFIG.outputDir, 'auto-review.ps1');

    const psContent = `
# PowerShell script to automate Copilot code review in VSCode
# Requires AutoHotkey on Windows

# Function to simulate keystrokes
function Send-Keystrokes {
    param (
        [string]$text
    )
    
    Add-Type -AssemblyName System.Windows.Forms
    [System.Windows.Forms.SendKeys]::SendWait($text)
    Start-Sleep -Milliseconds 500
}

# Open Copilot Chat
Write-Host "Opening Copilot Chat..."
Send-Keystrokes("^+i")  # Ctrl+Shift+I
Start-Sleep -Seconds 1

# Type the review command
Write-Host "Typing review command..."
Send-Keystrokes("/review")
Start-Sleep -Milliseconds 500
Send-Keystrokes("{ENTER}")

# Wait for the review to complete
Write-Host "Waiting for review to complete..."
Start-Sleep -Seconds 10

# Select all text
Write-Host "Selecting review text..."
Send-Keystrokes("^a")  # Ctrl+A
Start-Sleep -Milliseconds 500

# Copy the text
Write-Host "Copying review text..."
Send-Keystrokes("^c")  # Ctrl+C

Write-Host "Review completed and copied to clipboard."
`;

    fs.writeFileSync(scriptPath, psContent);
    console.log(`‚úÖ ƒê√£ t·∫°o script PowerShell automation t·∫°i ${scriptPath}`);
}

/**
 * T·∫°o t·∫≠p l·ªánh Bash ƒë·ªÉ t·ª± ƒë·ªông h√≥a review trong VSCode
 */
function createBashAutomation() {
    const scriptPath = path.join(CONFIG.outputDir, 'auto-review.sh');

    const bashContent = `#!/bin/bash
# Bash script to automate Copilot code review in VSCode
# Requires xdotool on Linux

# Function to simulate keystrokes
send_keystrokes() {
    if command -v xdotool &> /dev/null; then
        xdotool key "$1"
        sleep 0.5
    else
        echo "xdotool not found. Please install it with: sudo apt-get install xdotool"
        exit 1
    fi
}

# Wait for VSCode to be in focus
echo "Please focus on VSCode window in 5 seconds..."
sleep 5

# Open Copilot Chat
echo "Opening Copilot Chat..."
send_keystrokes "ctrl+shift+i"
sleep 1

# Type the review command
echo "Typing review command..."
xdotool type "/review"
sleep 0.5
send_keystrokes "Return"

# Wait for the review to complete
echo "Waiting for review to complete..."
sleep 10

# Select all text
echo "Selecting review text..."
send_keystrokes "ctrl+a"
sleep 0.5

# Copy the text
echo "Copying review text..."
send_keystrokes "ctrl+c"

echo "Review completed and copied to clipboard."
`;

    fs.writeFileSync(scriptPath, bashContent);
    fs.chmodSync(scriptPath, '755');
    console.log(`‚úÖ ƒê√£ t·∫°o script Bash automation t·∫°i ${scriptPath}`);
}

/**
 * T·∫°o h∆∞·ªõng d·∫´n s·ª≠ d·ª•ng cho ng∆∞·ªùi d√πng
 */
function createUserGuide() {
    const guidePath = path.join(CONFIG.outputDir, 'README.md');

    const guideContent = `# GitHub Copilot Review Automation Guide

## T·ªïng quan

Script n√†y gi√∫p t·ª± ƒë·ªông h√≥a quy tr√¨nh review code v·ªõi GitHub Copilot trong VSCode. N√≥ s·∫Ω qu√©t c√°c file trong project c·ªßa b·∫°n, m·ªü ch√∫ng trong VSCode v√† chu·∫©n b·ªã c√°c file review.

## C√°ch s·ª≠ d·ª•ng

### Y√™u c·∫ßu
- VSCode ƒë√£ ƒë∆∞·ª£c c√†i ƒë·∫∑t
- GitHub Copilot extension ƒë√£ ƒë∆∞·ª£c c√†i ƒë·∫∑t v√† k√≠ch ho·∫°t trong VSCode

### C√°c b∆∞·ªõc th·ª±c hi·ªán review t·ª± ƒë·ªông

1. Ch·∫°y script: \`node vscode-copilot-review.js\`
2. Script s·∫Ω t·∫°o c√°c file review trong th∆∞ m·ª•c \`${CONFIG.outputDir}\`
3. V·ªõi m·ªói file, VSCode s·∫Ω t·ª± ƒë·ªông m·ªü
4. B·∫°n c·∫ßn th·ª±c hi·ªán c√°c b∆∞·ªõc sau trong VSCode:
   - M·ªü Copilot Chat (Ctrl+Shift+I)
   - Nh·∫≠p l·ªánh \`/review\`
   - Sao ch√©p k·∫øt qu·∫£ review
   - D√°n v√†o file review t∆∞∆°ng ·ª©ng trong th∆∞ m·ª•c \`${CONFIG.outputDir}\`

### Script t·ª± ƒë·ªông h√≥a

Script ƒë√£ t·∫°o c√°c t·∫≠p l·ªánh t·ª± ƒë·ªông h√≥a cho Windows (PowerShell) v√† Linux (Bash):

#### Windows (PowerShell)
\`\`\`
${CONFIG.outputDir}/auto-review.ps1
\`\`\`

#### Linux (Bash - y√™u c·∫ßu xdotool)
\`\`\`
${CONFIG.outputDir}/auto-review.sh
\`\`\`

## T√πy ch·ªânh

B·∫°n c√≥ th·ªÉ t√πy ch·ªânh c·∫•u h√¨nh trong script \`vscode-copilot-review.js\`:
- \`extensions\`: Lo·∫°i file c·∫ßn review
- \`excludePaths\`: Th∆∞ m·ª•c/file c·∫ßn lo·∫°i tr·ª´
- \`outputDir\`: Th∆∞ m·ª•c l∆∞u k·∫øt qu·∫£ review

## Kh·∫Øc ph·ª•c s·ª± c·ªë

- N·∫øu VSCode kh√¥ng m·ªü, h√£y ki·ªÉm tra xem l·ªánh \`code\` ƒë√£ c√≥ trong PATH
- N·∫øu GitHub Copilot kh√¥ng ho·∫°t ƒë·ªông, h√£y ƒë·∫£m b·∫£o b·∫°n ƒë√£ ƒëƒÉng nh·∫≠p v√† k√≠ch ho·∫°t extension

## L∆∞u √Ω

- ƒê√¢y l√† ph∆∞∆°ng ph√°p b√°n t·ª± ƒë·ªông v√¨ GitHub Copilot kh√¥ng c√≥ API ch√≠nh th·ª©c
- K·∫øt qu·∫£ review c·∫ßn ƒë∆∞·ª£c ƒë√°nh gi√° b·ªüi con ng∆∞·ªùi
`;

    fs.writeFileSync(guidePath, guideContent);
    console.log(`üìù ƒê√£ t·∫°o h∆∞·ªõng d·∫´n s·ª≠ d·ª•ng t·∫°i ${guidePath}`);
}

/**
 * H√†m ch√≠nh
 */
async function main() {
    try {
        console.log('üöÄ B·∫Øt ƒë·∫ßu qu√° tr√¨nh review v·ªõi GitHub Copilot...');

        // Ki·ªÉm tra VSCode ƒë√£ ƒë∆∞·ª£c c√†i ƒë·∫∑t
        const vsCodeInstalled = await checkVSCode();
        if (!vsCodeInstalled) {
            console.error('‚ùå VSCode c·∫ßn ƒë∆∞·ª£c c√†i ƒë·∫∑t ƒë·ªÉ ti·∫øp t·ª•c.');
            process.exit(1);
        }

        // Ki·ªÉm tra GitHub Copilot extension
        const copilotInstalled = await checkCopilotExtension();
        if (!copilotInstalled) {
            console.warn('‚ö†Ô∏è Kh√¥ng ph√°t hi·ªán ƒë∆∞·ª£c GitHub Copilot extension. Ti·∫øp t·ª•c nh∆∞ng c√≥ th·ªÉ g·∫∑p v·∫•n ƒë·ªÅ.');
        }

        // T·∫°o VSCode tasks cho t·ª± ƒë·ªông h√≥a
        createVSCodeTask();

        // T·∫°o VSCode keybinding
        createVSCodeKeybinding();

        // T·∫°o script t·ª± ƒë·ªông h√≥a
        createPowerShellAutomation();
        createBashAutomation();

        // L·∫•y danh s√°ch t·∫•t c·∫£ c√°c file c·∫ßn review
        console.log('üìÅ ƒêang qu√©t project ƒë·ªÉ t√¨m c√°c file c·∫ßn review...');
        let files = getAllFiles('.', CONFIG.extensions, CONFIG.excludePaths);
        console.log(`üî¢ T√¨m th·∫•y ${files.length} file c·∫ßn review.`);

        if (files.length === 0) {
            console.log('‚ùì Kh√¥ng t√¨m th·∫•y file n√†o ƒë·ªÉ review. Vui l√≤ng ki·ªÉm tra l·∫°i c·∫•u h√¨nh.');
            process.exit(0);
        }

        // Gi·ªõi h·∫°n s·ªë l∆∞·ª£ng file
        if (files.length > CONFIG.maxFiles) {
            console.log(`‚ö†Ô∏è C√≥ qu√° nhi·ªÅu file (${files.length}). Ch·ªâ review ${CONFIG.maxFiles} file ƒë·∫ßu ti√™n.`);
            files = files.slice(0, CONFIG.maxFiles);
        }

        // T·∫°o README h∆∞·ªõng d·∫´n s·ª≠ d·ª•ng
        createUserGuide();

        // Review t·ª´ng file
        const results = [];
        for (let i = 0; i < files.length; i++) {
            console.log(`\nüìã File ${i + 1}/${files.length}: ${files[i]}`);
            const result = await reviewFile(files[i]);
            results.push(result);

            // ƒê·ª£i user nh·∫•n Enter ƒë·ªÉ ti·∫øp t·ª•c
            if (i < files.length - 1) {
                console.log('\n‚è±Ô∏è Nh·∫•n Enter sau khi ƒë√£ ho√†n th√†nh review file n√†y...');
                await new Promise(resolve => {
                    process.stdin.once('data', () => {
                        resolve();
                    });
                });
            }
        }

        console.log('\nüéâ ƒê√£ ho√†n th√†nh vi·ªác chu·∫©n b·ªã review!');
        console.log(`üìä File review ƒë∆∞·ª£c t·∫°o trong th∆∞ m·ª•c ${CONFIG.outputDir}`);
        console.log('üìù L√†m theo h∆∞·ªõng d·∫´n trong README.md ƒë·ªÉ ho√†n th√†nh c√°c review');

    } catch (error) {
        console.error('‚ùå L·ªói trong qu√° tr√¨nh review:', error.message);
        process.exit(1);
    }
}

// Ch·∫°y h√†m ch√≠nh
main();